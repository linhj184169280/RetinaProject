#coding:utf-8'''Created on Mar 6, 2015@author: linhuangjing'''import numpy as npimport cv2import sysfrom utils import GetPixelfrom utils import GetPatchfrom multiprocessing import Poolfrom multiprocessing.dummy import Pool as ThreadPoolimport pathos.pp_map as mpimport timefrom numbapro import vectorizefrom functools import partialimport copy_regimport types# conf_path='./configuration.txt'# file = open('./configuration.txt','rb')# line = file.readline()        #read configure PATHs from configuration.txt# while line:#     lineitems=line.split("\"")#     if lineitems[0][:12]=='PYCAFFE_ROOT':#         PYCAFFE_ROOT=lineitems[1]#     elif lineitems[0][:8]=='NET_FILE':#         NET_FILE = lineitems[1]#     elif lineitems[0][:18]=='TRAINED_MODEL_FILE':#         TRAINED_MODEL_FILE = lineitems[1]#     elif lineitems[0][:9]=='MEAN_FILE':#         MEAN_FILE = lineitems[1]#     line = file.readline()#     pass# sys.path.insert(0, PYCAFFE_ROOT)# import caffe# caffe.set_mode_gpu()class CNNSegNetworkBase:    '''    '''    #configure the network from configuration.txt    def __init__( self,conf_path ):        self._conf_path = conf_path        file = open(self._conf_path,'rb')        line = file.readline()        #read configure PATHs from configuration.txt        while line:            lineitems=line.split("\"")            if lineitems[0][:12]=='PYCAFFE_ROOT':                self._PYCAFFE_ROOT=lineitems[1]            elif lineitems[0][:8]=='NET_FILE':                self._NET_FILE = lineitems[1]            elif lineitems[0][:18]=='TRAINED_MODEL_FILE':                self._TRAINED_MODEL_FILE = lineitems[1]            elif lineitems[0][:9]=='MEAN_FILE':                self._MEAN_FILE = lineitems[1]            line = file.readline()            pass        #Import the caffe module        sys.path.insert(0, self._PYCAFFE_ROOT)        import caffe        caffe.set_mode_gpu()#         self._MEAN_FILE = MEAN_FILE#         self._NET_FILE = NET_FILE#         self._TRAINED_MODEL_FILE = TRAINED_MODEL_FILE        #read the mean image from the file        blob = caffe.proto.caffe_pb2.BlobProto()        data = open(self._MEAN_FILE,'rb').read()        blob.ParseFromString(data)        arr = np.array( caffe.io.blobproto_to_array(blob) )        self._mean_Img = arr[0]        #create the CNN network        self._net = caffe.Classifier(self._NET_FILE, self._TRAINED_MODEL_FILE, mean=self._mean_Img, channel_swap=(0,1,2), input_scale=1.0, raw_scale=1.0)            def setMeanImg(self, mean_Img):        '''        '''        self._mean_Img = mean_Img    def classifyPatches(self, n_Imgs):        '''        '''        predictions = self._net.predict(n_Imgs,False)        return predictions            def _GetPatch(self, originImg, row, col, windowShape):        '''Get a windowShape Patch from originImg in [row,col]           originImg is a "ndarray" type image.           row & col is "int" type coordinates.           windowShape is a window like [height,width,3]        '''         radius = windowShape[0]/2                px = col-radius        py = row-radius        qx = col+radius        qy = row+radius        if px<0:            px=0        if py<0:            py=0        if qx>=originImg.shape[1]:            qx=originImg.shape[1]-1        if qy>=originImg.shape[0]:            qy=originImg.shape[0]-1        patchImage = originImg[py:qy, px:qx, :]        return patchImage.astype(np.float32)                def _GetPatchesIndexList(self, presegImg):        '''        '''        indexesList = []        #Judge if the presegImg is a gray-scale image        if presegImg.ndim==3:            b,g,r = cv2.split(presegImg)        else:            g = presegImg        iter = g.flat        for i in xrange(g.size):            value = iter.next()            if value>30:                index = iter.coords                indexesList.append(np.asarray(index))        return np.asarray(indexesList)                         class ExudateCNNSegNetwork(CNNSegNetworkBase):    def __init__(self,conf_path):        CNNSegNetworkBase.__init__(self,conf_path)        def segment(self, origin_img, preseg_img, batchsize=10):        '''        '''        result = np.zeros(origin_img.shape, origin_img.dtype)        indexesList = self._GetPatchesIndexList(preseg_img)#         ParameterList = self._GetPatchesParameterList(origin_img, preseg_img)                i=0        ba_j=0        batch=[]        window = [origin_img.shape[0]/12, origin_img.shape[0]/12, 3]        flag=0        t=0        print str(indexesList.shape[0])+' pixels to be classified..'                while(i<indexesList.shape[0]):            index = indexesList[i]            patch = self._GetPatch(origin_img, index[0], index[1], window)            batch.append(patch)            ba_j=ba_j+1;            i=i+1            t=t+1            if t>indexesList.shape[0]/8:                print 'predicting...: '+str(float(i*100)/indexesList.shape[0])+'%'                t=0            #process $batchsize patches at a time            if ba_j==batchsize:                preds = self._net.predict(batch, False)                #predictions.append(preds)                if(flag==0):                    predictions = preds                    flag=1                else:                    predictions = np.concatenate((predictions, preds))                ba_j=0                batch = []                         if batch!=[]:            preds = self._net.predict(batch, False)            if(flag==0):                predictions = preds                flag=1            else:                predictions = np.concatenate((predictions, preds))            ba_j=0            batch = []        #Set the result        for i in xrange(len(predictions)):            if predictions[i][2]>0.75:                result[indexesList[i,0],indexesList[i,1]] = [255, 255, 255]#             elif predictions[i][1]>0.5:#                 result[indexesList[i,0],indexesList[i,1]] = [0, 255, 0]#             elif predictions[i][0]>0.5:#                 result[indexesList[i,0],indexesList[i,1]] = [255, 0, 0]        return result        class HamorCNNSegNetwork(CNNSegNetworkBase):    def __init__(self,conf_path):        CNNSegNetworkBase.__init__(self,conf_path)        def segment(self, origin_img, preseg_img, batchsize=10):        '''        '''        result = np.zeros(origin_img.shape, origin_img.dtype)        indexesList = self._GetPatchesIndexList(preseg_img)#         ParameterList = self._GetPatchesParameterList(origin_img, preseg_img)                i=0        ba_j=0        batch=[]        window = [origin_img.shape[0]/12, origin_img.shape[0]/12, 3]        flag=0        t=0        print str(indexesList.shape[0])+' pixels to be classified..'                while(i<indexesList.shape[0]):            index = indexesList[i]            patch = self._GetPatch(origin_img, index[0], index[1], window)            batch.append(patch)            ba_j=ba_j+1;            i=i+1            t=t+1            if t>indexesList.shape[0]/8:                print 'predicting...: '+str(float(i*100)/indexesList.shape[0])+'%'                t=0            #process $batchsize patches a time            if ba_j==batchsize:                preds = self._net.predict(batch, False)                #predictions.append(preds)                if(flag==0):                    predictions = preds                    flag=1                else:                    predictions = np.concatenate((predictions, preds))                ba_j=0                batch = []                         if batch!=[]:            preds = self._net.predict(batch, False)            if(flag==0):                predictions = preds                flag=1            else:                predictions = np.concatenate((predictions, preds))            ba_j=0            batch = []        #Set the result        for i in xrange(len(predictions)):            if predictions[i][2]>0.5:                result[indexesList[i,0],indexesList[i,1]] = [255, 255, 255]#            elif predictions[i][1]>0.5:#                result[indexesList[i,0],indexesList[i,1]] = [0, 0, 255] #           elif predictions[i][0]>0.5: #               result[indexesList[i,0],indexesList[i,1]] = [255, 0, 0]        result = result.astype(np.uint8)        result = cv2.medianBlur(result,5)                return result     def SegBatch(originImg, windowSize, _NET_FILE, _TRAINED_MODEL_FILE, _mean_Img, SubIndexesList):    m,n,c = originImg.shape    k,d = SubIndexesList.shape    w = windowSize    batch=[]    for i in xrange(k):    #   Batch[i,:,:,:] = GetPatch(originImg, SubIndexesList[i,0], SubIndexesList[i,1], w)            patch = GetPatch(originImg, SubIndexesList[i,0], SubIndexesList[i,1], w)            batch.append(patch)    import caffe    caffe.set_mode_gpu()        net = caffe.Classifier(_NET_FILE, _TRAINED_MODEL_FILE, mean=_mean_Img, channel_swap=(0,1,2), input_scale=1.0, raw_scale=1.0)    preds = net.predict(batch, False)    del net#     return predsclass HamorCNNSegNetworkParallel(CNNSegNetworkBase):    def __init__(self,conf_path):        CNNSegNetworkBase.__init__(self,conf_path)        def _SegBatch(self, originImg, windowSize, SubIndexesList):        m,n,c = originImg.shape        k,d = SubIndexesList.shape        w = windowSize        batch=[]        for i in xrange(k):    #         Batch[i,:,:,:] = GetPatch(originImg, SubIndexesList[i,0], SubIndexesList[i,1], w)                patch = GetPatch(originImg, SubIndexesList[i,0], SubIndexesList[i,1], w)                batch.append(patch)#         preds = self._net.predict(batch, False)#         return preds        def segment(self, origin_img, preseg_img, batchsize=10):        '''        '''        result = np.zeros(origin_img.shape, origin_img.dtype)        indexesList = self._GetPatchesIndexList(preseg_img)                print str(indexesList.shape[0])+' pixels to be classified..'        #         ParameterList = self._GetPatchesParameterList(origin_img, preseg_img)        windowSize = origin_img.shape[0]/12        windowSize = windowSize/2*2                i_Size = indexesList.shape[0]/batchsize        SubIndexesListSet = np.zeros((i_Size, batchsize, 2),indexesList.dtype)        for i in xrange(i_Size):            SubIndexesListSet[i] = indexesList[i*batchsize:(i+1)*batchsize]                #Import the caffe module#         sys.path.insert(0, self._PYCAFFE_ROOT)#         import caffe#         caffe.set_mode_gpu()#         net = caffe.Classifier(self._NET_FILE, self._TRAINED_MODEL_FILE, mean=self._mean_Img, channel_swap=(0,1,2), input_scale=1.0, raw_scale=1.0)                        partial_GetBatch = partial(SegBatch, origin_img, windowSize, self._NET_FILE, self._TRAINED_MODEL_FILE, self._mean_Img)                        time1 = time.time()        pool = Pool(1)        pool.map(partial_GetBatch, SubIndexesListSet)        time2 = time.time()        alltime=time2-time1           print "all time = ",alltime                print "Com"        pool.close()        pool.join()#         i=0#         ba_j=0#         batch=[]#         window = [origin_img.shape[0]/12, origin_img.shape[0]/12, 3]#         flag=0#         t=0#         print str(indexesList.shape[0])+' pixels to be classified..'#          #         while(i<indexesList.shape[0]):#             index = indexesList[i]#             patch = self._GetPatch(origin_img, index[0], index[1], window)#             batch.append(patch)#             ba_j=ba_j+1;#             i=i+1#             t=t+1#             if t>indexesList.shape[0]/8:#                 print 'predicting...: '+str(float(i*100)/indexesList.shape[0])+'%'#                 t=0#             #process $batchsize patches a time#             if ba_j==batchsize:#                 preds = self._net.predict(batch, False)#                 #predictions.append(preds)#                 if(flag==0):#                     predictions = preds#                     flag=1#                 else:#                     predictions = np.concatenate((predictions, preds))#                 ba_j=0#                 batch = []       #   #           #         if batch!=[]:#             preds = self._net.predict(batch, False)#             if(flag==0):#                 predictions = preds#                 flag=1#             else:#                 predictions = np.concatenate((predictions, preds))#             ba_j=0#             batch = []#         #Set the result#         for i in xrange(len(predictions)):#             if predictions[i][2]>0.5:#                 result[indexesList[i,0],indexesList[i,1]] = [255, 255, 255]# #            elif predictions[i][1]>0.5:# #                result[indexesList[i,0],indexesList[i,1]] = [0, 0, 255]#  #           elif predictions[i][0]>0.5:#  #               result[indexesList[i,0],indexesList[i,1]] = [255, 0, 0]#         result = result.astype(np.uint8)#         result = cv2.medianBlur(result,5)#          #         return result                            